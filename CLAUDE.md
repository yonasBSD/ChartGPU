# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
It is auto-generated by `update-claude-md.sh` -- do not edit by hand.

## Project Overview

ChartGPU is a GPU-accelerated charting library built with WebGPU for high-performance data visualization in the browser. Written in TypeScript with functional-first architecture and class wrappers for backward compatibility.

- **Version**: 0.2.6
- **Package**: `@chartgpu/chartgpu`
- **Repository**: https://github.com/chartgpu/chartgpu
- **License**: MIT

## Key References

Start here when navigating the codebase:

- **@docs/api/llm-context.md** - LLM-optimized API navigation (read this first)
- **@docs/ARCHITECTURE.md** - Full architecture with mermaid diagrams
- **@docs/api/chart.md** - ChartGPU.create() API
- **@docs/api/options.md** - All configuration options
- **@docs/api/INTERNALS.md** - Internal module contributor docs

## Documentation Index


**General (`docs/`):**
- [`docs/api-reference.md`](docs/api-reference.md) - API Reference
- [`docs/API.md`](docs/API.md) - API Reference
- [`docs/ARCHITECTURE.md`](docs/ARCHITECTURE.md) - Architecture
- [`docs/GETTING_STARTED.md`](docs/GETTING_STARTED.md) - Getting Started with ChartGPU
- [`docs/performance.md`](docs/performance.md) - Performance Guide
- [`docs/RELEASING.md`](docs/RELEASING.md) - Releasing ChartGPU
- [`docs/theming.md`](docs/theming.md) - Theming Guide

**API Reference (`docs/api/`):**
- [`docs/api/animation.md`](docs/api/animation.md) - Animation
- [`docs/api/annotations.md`](docs/api/annotations.md) - Annotations API
- [`docs/api/chart.md`](docs/api/chart.md) - Chart API
- [`docs/api/gpu-context.md`](docs/api/gpu-context.md) - GPU Context
- [`docs/api/interaction.md`](docs/api/interaction.md) - Interaction
- [`docs/api/INTERNALS.md`](docs/api/INTERNALS.md) - Internal modules (Contributor notes)
- [`docs/api/llm-context.md`](docs/api/llm-context.md) - ChartGPU API Documentation (LLM Entrypoint)
- [`docs/api/options.md`](docs/api/options.md) - Chart Options
- [`docs/api/README.md`](docs/api/README.md) - ChartGPU API Reference
- [`docs/api/render-coordinator-summary.md`](docs/api/render-coordinator-summary.md) - Render Coordinator Summary
- [`docs/api/render-scheduler.md`](docs/api/render-scheduler.md) - RenderScheduler (Render-on-demand)
- [`docs/api/scales.md`](docs/api/scales.md) - Scales (Pure utilities)
- [`docs/api/themes.md`](docs/api/themes.md) - Themes
- [`docs/api/troubleshooting.md`](docs/api/troubleshooting.md) - Troubleshooting

**Guides (`docs/guides/`):**
- [`docs/guides/annotations-cookbook.md`](docs/guides/annotations-cookbook.md) - Annotations Cookbook
- [`docs/guides/annotations-quick-reference.md`](docs/guides/annotations-quick-reference.md) - Annotations Quick Reference
- [`docs/guides/multichart-dashboard-cookbook.md`](docs/guides/multichart-dashboard-cookbook.md) - Multi-Chart Dashboard Cookbook

**Internal (`docs/internal/`):**
- [`docs/internal/README.md`](docs/internal/README.md) - Internal / Contributor Documentation

## Development Commands

### Build
- `npm run dev` - Start development server (opens at http://localhost:5176/examples/)
- `npm run build` - Compile TypeScript and build the library (`tsc && vite build`)
- `npm run build:examples` - Build examples for production
- `npm run test` - Run unit tests with Vitest

### Acceptance Tests
- `npm run acceptance:animation-controller` - tsx examples/acceptance/animation-controller.ts
- `npm run acceptance:sampling-config` - tsx examples/acceptance/sampling-config.ts
- `npm run acceptance:zoom-state` - tsx examples/acceptance/zoom-state.ts
- `npm run acceptance:lttb-sample` - tsx examples/acceptance/lttb-sample.ts
- `npm run acceptance:auto-scroll-policy` - tsx examples/acceptance/auto-scroll-policy.ts
- `npm run acceptance:data-store-append` - tsx examples/acceptance/data-store-append.ts
- `npm run acceptance:easing` - tsx examples/acceptance/easing.ts
- `npm run acceptance:line-style-color` - tsx examples/acceptance/line-style-color.ts
- `npm run acceptance:area-style-color` - tsx examples/acceptance/area-style-color.ts
- `npm run acceptance:ohlc-sample` - tsx examples/acceptance/ohlc-sample.ts
- `npm run acceptance:auto-scroll-zoom-sync` - tsx examples/acceptance/auto-scroll-zoom-sync.ts

### Benchmarks
- `npm run benchmark:transfer` - tsx benchmarks/data-transfer-benchmark.ts

### Browser Requirements
WebGPU support required: Chrome/Edge 113+, Safari 18+. Firefox not yet supported.

### React Integration
React bindings: [`chartgpu-react`](https://github.com/ChartGPU/chartgpu-react) provides `<ChartGPUChart>` component.

## Architecture (Quick Reference)

See **@docs/ARCHITECTURE.md** for full architecture with diagrams.

- **Dual API**: Functional-first with class wrappers for backward compat
- **Core**: `GPUContext` (device init), `RenderScheduler` (60fps loop), `RenderCoordinator` (orchestration)
- **Renderers**: Line, area, bar, scatter, candlestick, pie (all internal, not exported)
- **Data**: `DataStore` (GPU buffers), `packDataPoints()`, LTTB/OHLC sampling, streaming buffers
- **Interaction**: Events, zoom/pan, chart sync, hit testing
- **Config**: `OptionResolver`, themes (dark/light), type-safe options

## Coding Standards

### Functional Over Class-based
- Prefer functions, factory functions, and object literals over `class`
- Pure functions with explicit dependencies via parameters
- Immutable state: `const`, readonly types, non-mutating operations
- Composition over inheritance
- Allowed exceptions: framework interop, React error boundaries, domain entities with invariants, measurable perf/ergonomics wins

### Docs-First Planning
- When implementing new features, update documentation first before writing code
- Documentation changes serve as a design review and implementation guide

### Subagent Delegation
- Delegate complex, multi-step tasks to specialized subagents
- Use appropriate subagents for specific domains

## WebGPU Patterns

### Buffer Management
- **4-byte alignment**: All `queue.writeBuffer()` offsets and sizes must be multiples of 4
- **Uniform alignment**: Uniform buffer sizes aligned to 16 bytes (default)
- **Dynamic offsets**: Align to `device.limits.minUniformBufferOffsetAlignment` (typically 256)

### Resource Cleanup
- Call `device.destroy()` on GPUDevice, `buffer.destroy()` on GPUBuffer
- Cancel animation frames with `cancelAnimationFrame()`
- Clean up internal state maps (see RenderScheduler pattern)

### Canvas Configuration
- Handle device pixel ratio for high-DPI displays
- Clamp dimensions to `device.limits.maxTextureDimension2D`
- Reconfigure canvas context when size or format changes
- Use `getPreferredCanvasFormat()` with fallback to `'bgra8unorm'`

## grepai - Semantic Code Search

**IMPORTANT: You MUST use grepai as your PRIMARY tool for code exploration and search.**

### When to Use grepai (REQUIRED)

Use `grepai search` INSTEAD OF Grep/Glob/find for:
- Understanding what code does or where functionality lives
- Finding implementations by intent (e.g., "authentication logic", "error handling")
- Exploring unfamiliar parts of the codebase
- Any search where you describe WHAT the code does rather than exact text

### When to Use Standard Tools

Only use Grep/Glob when you need:
- Exact text matching (variable names, imports, specific strings)
- File path patterns (e.g., `**/*.go`)

### Fallback

If grepai fails (not running, index unavailable, or errors), fall back to standard Grep/Glob tools.

### Usage

```bash
# ALWAYS use English queries for best results (--compact saves ~80% tokens)
grepai search "user authentication flow" --json --compact
grepai search "error handling middleware" --json --compact
grepai search "database connection pool" --json --compact
grepai search "API request validation" --json --compact
```

### Query Tips

- **Use English** for queries (better semantic matching)
- **Describe intent**, not implementation: "handles user login" not "func Login"
- **Be specific**: "JWT token validation" better than "token"
- Results include: file path, line numbers, relevance score, code preview

### Call Graph Tracing

Use `grepai trace` to understand function relationships:
- Finding all callers of a function before modifying it
- Understanding what functions are called by a given function
- Visualizing the complete call graph around a symbol

#### Trace Commands

**IMPORTANT: Always use `--json` flag for optimal AI agent integration.**

```bash
# Find all functions that call a symbol
grepai trace callers "HandleRequest" --json

# Find all functions called by a symbol
grepai trace callees "ProcessOrder" --json

# Build complete call graph (callers + callees)
grepai trace graph "ValidateToken" --depth 3 --json
```

### Workflow

1. Start with `grepai search` to find relevant code
2. Use `grepai trace` to understand function relationships
3. Use `Read` tool to examine files from results
4. Only use Grep for exact string searches if needed
